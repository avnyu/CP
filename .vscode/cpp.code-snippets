{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"C++ default": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ll long long",
			"#define ii pair<int, int>",
			"#define pll pair<ll, ll>",
			"#define dd pair<double, double>",
			"#define vi vector<int>",
			"#define vl vector<ll>",
			"#define vd vector<double>",
			"#define vii vector<ii>",
			"#define vll vector<pll>",
			"#define vdd vector<dd>",
			"#define vvi vector<vi>",
			"#define vvl vector<vl>",
			"#define vvd vector<vd>",
			"#define vvii vector<vii>",
			"#define vvll vector<vll>",
			"#define vvdd vector<vdd>",
			"#define fi first",
			"#define se second",
			"#define uni(v) v.erase(unique(v.begin(), v.end()), v.end())",
			"#define gcd(a, b) __gcd(a, b)",
			"#define lcm(a, b) (ll) a / __gcd(a, b) * b",
			"",
			"using namespace std;",
			"",
			"void print();",
			"template <typename T, typename... Args>",
			"void print(T x, Args... args);",
			"",
			"void solve(int T) {",
			"",
			"}",
			"int main() {",
			"    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);",
			"",
			"    int t = 1;",
			"    cin >> t;",
			"    for (int i = 0; i++ < t;) solve(i);",
			"",
			"    return 0;",
			"}",
			"",
			"void print() { cout << \"\\n\"; }",
			"template <typename T, typename... Args>",
			"void print(T x, Args... args) {",
			"    if (sizeof...(args)) {",
			"        cout << x << ' ';",
			"        print(args...);",
			"    } else {",
			"        cout << x << endl;",
			"    }",
			"}"
		],
		"description": "C++ default"
	},
	"CHT": {
		"prefix": "cht",
		"body": [
			"namespace CHT {",
			"const ll M = INT64_MAX;",
			"vector<pll> cht;",
			"vector<double> pt;",
			"double intersect(pll &x, pll &y) { return double(x.se - y.se) / (y.fi - x.fi); }",
			"void add(pll line) {",
			"    if (cht.size() && cht.back().fi == line.fi) {",
			"        pt.pop_back();",
			"        cht.pop_back();",
			"    }",
			"    while (cht.size() && intersect(cht.back(), line) <= pt.back()) {",
			"        pt.pop_back();",
			"        cht.pop_back();",
			"    }",
			"    pt.push_back(cht.empty() ? -M : intersect(cht.back(), line));",
			"    cht.push_back(line);",
			"}",
			"void add_lines(vector<pll> lines) {",
			"    int n = lines.size();",
			"    sort(lines.begin(), lines.end());",
			"    for (int i = 0; i < n; ++i) add(lines[i]);",
			"}",
			"ll get(ll x) {",
			"    auto p = upper_bound(pt.begin(), pt.end(), double(x)) - pt.begin() - 1;",
			"    return cht[p].fi * x + cht[p].se;",
			"}",
			"void reset() {",
			"    cht.clear();",
			"    pt.clear();",
			"}",
			"}  // namespace CHT"
		],
		"description": "CHT"
	},
	"Fast pow with mod": {
		"prefix": "fpow",
		"body": [
			"ll fpow(ll b, ll n, ll m = M) {",
			"\tll res = 1;",
			"\twhile (n) {",
			"\t\tif (n & 1) res = (res * b) % m;",
			"\t\tn >>= 1;",
			"\t\tb = (b * b) % m;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "Fast pow with mod"
	},
	"RB Tree": {
		"prefix": "rbtree",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"template <typename T>",
			"using rbtree =",
			"\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
		],
		"description": "Red-black Tree"
	},
	"Euler's Totient": {
		"prefix": "eulertotient",
		"body": [
			"ll eulerTotient(ll n) {",
			"\tif (n == 0) return 0;",
			"\tll ans = n;",
			"\tfor (ll x = 2; x * x <= n; ++x) {",
			"\t\tif (n % x == 0) {",
			"\t\t\tans -= ans / x;",
			"\t\t\twhile (n % x == 0) n /= x;",
			"\t\t}",
			"\t}",
			"\tif (n > 1) ans -= ans / n;",
			"\treturn ans;",
			"}"
		],
		"description": "Euler's Totient"
	},
	"Suffix Array": {
		"prefix": "suf",
		"body": [
			"struct SA {",
			"    string s;",
			"    int n, lgn;",
			"    vi suf, lcp, rank;",
			"    vvi st;",
			"    void init(string const& str, bool _lcp, bool _st);",
			"    void init_lcp();",
			"    void init_st();",
			"    int lcp_query(int l, int r);",
			"    int lower_bound(string const& x);",
			"    int upper_bound(string const& x);",
			"    bool is_substr(string const& x);",
			"};",
			"void SA::init(string const& str, bool _lcp, bool _st) {",
			"    const int alphabet = 128;",
			"    s = str + str;",
			"    n = s.size() >> 1;",
			"    lgn = 32 - __builtin_clz(n);",
			"    suf.assign(n, 0);",
			"    vi c(n), cnt(max(alphabet, n), 0);",
			"    for (int i = 0; i < n; i++) cnt[s[i]]++;",
			"    for (int i = 1; i < alphabet; i++) cnt[i] += cnt[i - 1];",
			"    for (int i = 0; i < n; i++) suf[--cnt[s[i]]] = i;",
			"    c[suf[0]] = 0;",
			"    int classes = 1;",
			"    for (int i = 1; i < n; i++) {",
			"        if (s[suf[i]] != s[suf[i - 1]]) classes++;",
			"        c[suf[i]] = classes - 1;",
			"    }",
			"    vi pn(n), cn(n);",
			"    for (int h = 1; h < n; h <<= 1) {",
			"        for (int i = 0; i < n; i++) {",
			"            pn[i] = suf[i] - h;",
			"            if (pn[i] < 0) pn[i] += n;",
			"        }",
			"        fill(cnt.begin(), cnt.begin() + classes, 0);",
			"        for (int i = 0; i < n; i++) cnt[c[pn[i]]]++;",
			"        for (int i = 1; i < classes; i++) cnt[i] += cnt[i - 1];",
			"        for (int i = n; i--;) suf[--cnt[c[pn[i]]]] = pn[i];",
			"        cn[suf[0]] = 0;",
			"        classes = 1;",
			"        for (int i = 1; i < n; i++) {",
			"            ii cur = {c[suf[i]], c[(suf[i] + h) % n]};",
			"            ii prev = {c[suf[i - 1]], c[(suf[i - 1] + h) % n]};",
			"            if (cur != prev) ++classes;",
			"            cn[suf[i]] = classes - 1;",
			"        }",
			"        c.swap(cn);",
			"    }",
			"",
			"    if (_lcp) init_lcp();",
			"    if (_lcp && _st) init_st();",
			"}",
			"void SA::init_lcp() {",
			"    int k = 0;",
			"    rank.assign(n, 0);",
			"    lcp.assign(n, 0);",
			"    for (int i = 0; i < n; ++i) rank[suf[i]] = i;",
			"    for (int i = 0; i < n; ++i) {",
			"        int j = suf[(rank[i] + 1) % n];",
			"        while (i + k < n && j + k < n && s[i + k] == s[j + k]) ++k;",
			"        lcp[rank[i]] = k;",
			"        if (k) --k;",
			"    }",
			"}",
			"void SA::init_st() {",
			"    st.assign(n, vi(lgn, -1));",
			"    for (int i = 0; i < n; ++i) st[i][0] = lcp[i];",
			"    for (int j = 1; j < lgn; ++j)",
			"        for (int i = 0; i < n - (1 << j); ++i)",
			"            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
			"}",
			"int SA::lower_bound(string const& x) {",
			"    int k = x.size(), res = n, add = 1 << lgn;",
			"    while (add) {",
			"        if (res - add >= 0 && s.compare(suf[res - add], k, x) >= 0) res -= add;",
			"        add >>= 1;",
			"    }",
			"    return res;",
			"}",
			"int SA::upper_bound(string const& x) {",
			"    int k = x.size(), res = n, add = 1 << lgn;",
			"    while (add) {",
			"        if (res - add >= 0 && s.compare(suf[res - add], k, x) > 0) res -= add;",
			"        add >>= 1;",
			"    }",
			"    return res;",
			"}",
			"bool SA::is_substr(string const& x) {",
			"    int p = lower_bound(x), k = x.size();",
			"    if (p == n) return false;",
			"    return s.compare(p, k, x) == 0;",
			"}",
			"int SA::lcp_query(int l, int r) {",
			"    if (l == r) return n;",
			"    int j = 31 - __builtin_clz(r - l);",
			"    return min(st[l][j], st[r - (1 << j)][j]);",
			"}",
			"int lowest(int l, int r, SA& sfa) {",
			"    int res = sfa.rank[l], add = 1 << 30, len = r - l + 1;",
			"    while (add) {",
			"        if (res - add >= 0 && sfa.lcp_query(res - add, res) >= len) res -= add;",
			"        add >>= 1;",
			"    }",
			"    return res;",
			"}",
			"void solve() {",
			"    string s;",
			"    cin >> s;",
			"    s.push_back(char(32));",
			"",
			"    SA sfa;",
			"    sfa.init(s, 1, 1);",
			"    s += s;",
			"",
			"    int n;",
			"    cin >> n;",
			"    vii a(n);",
			"    for (auto& i : a) {",
			"        cin >> i.fi >> i.se;",
			"        --i.fi;",
			"        --i.se;",
			"    }",
			"",
			"    vvi res(n, vi(4));",
			"    for (int i = 0; i < n; ++i) {",
			"        res[i][0] = lowest(a[i].fi, a[i].se, sfa);",
			"        res[i][1] = a[i].se - a[i].fi;",
			"        res[i][2] = a[i].fi;",
			"        res[i][3] = a[i].se;",
			"    }",
			"",
			"    sort(res.begin(), res.end());",
			"",
			"    for (auto& i : res) cout << i[2] + 1 << ' ' << i[3] + 1 << '\\n';",
			"}"
		],
		"description": "Suffix Array"
	}
}